import datetime
import json
import jsonschema
import sys

schemaFile:str = '../argspec/arguments.schema.json'

typeMap:dict = {
    'string' : 'String',
    'char' : 'Char',
    'int' : 'Integer',
    'flag' : 'Bool'
}

argHeader:str = '-- Argument parser generated by arggen at %s\nmodule Args where\nimport System.Environment\nimport Data.Char\nimport Data.List\n\nnewtype Error = Error String\n' % datetime.datetime.now()
argSpecSetup:str = '''\
parseArgv :: IO Args
parseArgv = do 
    args <- getArgs 
    return $ parseArgs' args

parseArgs :: [String] -> Args
parseArgs args = parseArgs' args

makeChar :: String -> Char
makeChar [] = error "Characters should be non-empty"
makeChar xs
    | length xs == 0 = error "Please give a character"
    | length xs >= 2 = error "Too many characters given, expected one here"
    | otherwise = xs!!0
'''

def printe(arg:str) -> None:
    print(arg, file=sys.stderr)

def formatDefaultArg(default, defaultType:str):
    if defaultType == 'String':
        return f'"{default}"'
    elif defaultType == 'Char':
        return f"'{default}'"
    else:
        return default

def isValidDest(dest:str) -> bool:
    return len(dest) > 0 and 'a' < dest[0] and dest[0] < 'z' and ' ' not in dest

def main(args:[str]) -> int:
    if len(args) < 1:
        printe('More arguments please!')
        return -1

    spec:dict
    with open(args[0], 'r+') as i:
        spec = json.load(i)

    schema:dict
    with open(schemaFile, 'r+') as i:
        schema = json.load(i)
    # schema = json.loads(rawSchema)

    try:
        jsonschema.validate(instance=spec, schema=schema)
    except jsonschema.exceptions.ValidationError as ve:
        printe(f'Input specification did not match the schema (using schema: "{schemaFile}"')
        printe(str(ve))
        return -1

    matchLines:[str] = ['parseArgs\' :: [String] -> Args']
    validatorLines:[str] = ['validArg :: (String,String) -> Bool']
    argTypes:str = ''
    defaultArgs:[str] = []

    for arg in spec['args']:
        # if arg['optional']:
        shortName:str = arg['short']
        longName:str = arg['long']
        dest:str = arg['dest']
        argtype:str = typeMap[arg['type']]
        default = arg['default']

        if not isValidDest(dest):
            printe(f'Invalid destination: "{dest}"')
            return 1

        getArgString:str
        if argtype == 'Integer':
            getArgString = f'read x :: Integer'
        elif argtype == 'Char':
            getArgString = f'makeChar x'
        elif argtype == 'Bool':
            getArgString = 'True'
        else:
            getArgString = 'x'
        # if argtype == 'String':
        # = f'read x :: {argtype} ' 
        #  argtype != 'Char' else 'x'

        matchLines.append(f'parseArgs\' ("{shortName}":x:args) = (parseArgs\' args) {{ {dest} = {getArgString} }}')
        matchLines.append(f'parseArgs\' ("{longName}":x:args) = (parseArgs\' args) {{ {dest} = {getArgString} }}')
        validatorLines.append(f'validArg ("{dest}",s) = isNum s')

        formattedDefault = formatDefaultArg(default, argtype)
        defaultArgs.append(f'{dest} = {formattedDefault}')
        argTypes += (', ' if argTypes != '' else '') + f'{dest} :: {argtype}'
        # else:
        #     matchLines.append(f'parseArgs\' (a:as) = parseArgs\' as ++ [("{dest}",a)]')
        #     validatorLines.append(f'validArg ("{dest}",s) = isFileName s')
            

    matchLines.append('parseArgs\' [] = defaultArgs')
    matchLines.append('parseArgs\' args = error $ "Could not parse rest of arguments: " ++ (intercalate " " args)')
    validatorLines.append('validArg _ = True')
    argTypes = f'data Args = Args {{ {argTypes} }}\n    deriving Show'
    defaultArgsString:str = ', '.join(defaultArgs)
    defaultArgsString = f'defaultArgs :: Args\ndefaultArgs = Args {{ {defaultArgsString} }}'

    print(argHeader, end='\n\n')
    print(argTypes, end='\n\n')
    print(defaultArgsString)
    print(argSpecSetup)
    print('\n'.join(matchLines), end='\n\n')
    # print('\n'.join(validatorLines))
    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))