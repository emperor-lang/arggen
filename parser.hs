-- Argument parser, generated by arggen

import System.Environment
import Data.Char

newtype Error = Error String

instance Show Error where
    show (Error e) = e
    
main :: IO ()
main = do
    args <- getArgs 
    let argMap = parseArgs args in
        case argMap of
            Left map -> print $ argString map
            Right error -> print $ show error
        where 
            argString ((k,v):as) = "(" ++ show k ++ ", " ++ show v ++ ") " ++ argString as
            argString [] = []

parseArgv :: IO [(String,String)]
parseArgv = do 
    args <- getArgs 
    return $ parseArgs' args
    
parseArgs :: [String] -> Either [(String,String)] Error
parseArgs args = if validArgs parsedArgs then
                    Left parsedArgs
                else
                    Right (Error ("Invalid arguments: " ++ show (filter (not . validArg) parsedArgs)))
                    where
                        parsedArgs = parseArgs' args

parseArgs' :: [String] -> [(String,String)]
parseArgs' ("-v":v:args) = parseArgs' args ++ [("verbose",v)]
parseArgs' (a:as) = parseArgs' as ++ [("file", a)]
parseArgs' [] = []

validArgs :: [(String,String)] -> Bool
validArgs = all validArg

validArg :: (String,String) -> Bool
validArg ("verbose",s) = isNum s
validArg ("file", fs) = isFileName fs
validArg _ = True

isFileName :: String -> Bool
isFileName s = True

isNum :: String -> Bool
isNum = all isNum'
    where
        isNum' :: Char -> Bool
        isNum' c = ord '0' <= ord c && ord c <= ord '1'