import datetime
import json
import jsonschema
import sys
import re

defaultSchemaFile:str = '../argspec/coder-arguments-schema.json'
shebang:str = '#!/usr/bin/python3'

arggenVersion:str = 'v1.0.0'

argHeader:str = 'Argument parser generated by arggen %s at %s' % (arggenVersion, datetime.datetime.now())

imports:[str] = [
	'import argparse',
	'import sys',
	'import re'
]

def printe(*args, **kwargs) -> None:
	print(*args, file=sys.stderr, **kwargs)

def wrapDefaultValue(value:str, valueType:str) -> str:
	if valueType == 'string':
		return f'"{value}"'
	elif valueType == 'char':
		return f"'{value}'"
	else:
		return value

booleanMap:dict = {
	'true': 'True',
	'false' : 'False'
}

# Format a value inputted from the JSON
def formatValue(inputType:str, value:str) -> str:
	if inputType in ['string', 'char']:
		return f"'{value}'"
	elif value in booleanMap.keys():
		return booleanMap[value]
	else:
		return value

def toPython(spec:dict) -> int:
	argumentLines:[str] = []
	validatorLines:[str] = []
	for arg in spec['args']:
		parserOptions:[str] = ([f"'{arg['short']}'"] if 'short' in arg else []) + ([f"'{arg['long']}'"] if 'long' in arg else [])

		# Add help text
		if 'help' in arg:
			helpString:str = arg['help'].replace('\'', '\\\'')
			helpString[0] = chr(helpString[0].lower())
			parserOptions.append(f"help='{helpString}'")

		# Add the destination
		if 'dest' in arg and arg['type'] != 'help':
			parserOptions.append(f"dest='{arg['dest']}'")

		# Grab and handle the right argument parts
		if arg['type'] == 'string':
			parserOptions.append('type = str')
		elif arg['type'] == 'int':
			parserOptions.append('type = int')
		elif arg['type'] == 'char':
			parserOptions.append('type = str')
			validatorLines.append(f'if len(args.{arg["dest"]}) > 1:')
			validatorLines.append(f'\tprint(f\'Expected single character for {arg["short"] if "short" in arg else arg["long"]}, got "{{args.{arg["dest"]}}}"\', file=sys.stderr)')
			validatorLines.append(f'\treturn False')
		elif arg['type'] == 'bool':
			parserOptions.append('type = bool')
			validatorLines.append(f'if args.{arg["dest"]} not in [\'true\', \'false\']:')
			validatorLines.append(f'\treturn False')
		elif arg['type'] == 'flag':
			parserOptions.append("action='store_true'")
		elif arg['type'] == 'help':
			parserOptions.append("action='help'")


		# Handle the default value if necessary
		if 'default' in arg and arg['type'] != 'help':
			parserOptions.append(f"default={formatValue(arg['type'], arg['default'])}")

		argumentLine:str = f'parser.add_argument({", ".join(parserOptions)})'
		argumentLines.append(argumentLine)

	parserGeneratorArguments:[str] = ['add_help=False']
	if 'description' in spec:
		parserGeneratorArguments.append(f"description='{spec['description']}'")
	parserGeneratorArgumentsString:str = ', '.join(parserGeneratorArguments)
	parserMethodHeader:str = 'def parseArgs(args:[str]=sys.argv[1:]) -> argparse.Namespace:'
	parserMethodBody:[str] = [
		f'parser:argparse.ArgumentParser = argparse.ArgumentParser({parserGeneratorArgumentsString})',
		'',
	] + argumentLines + [
		'',
		'arguments:argparse.Namespace = parser.parse_args(args)',
		'',
		'if not validateArgs(arguments):',
		"\tsys.exit(125)",
		'',
		'return arguments'
	]
	parserMethod:str = parserMethodHeader + '\n\t' + '\n\t'.join(parserMethodBody)

	validatorMethodHeader:str = 'def validateArgs(args:argparse.Namespace) -> bool:'
	validatorMethod:[str] = [
        validatorMethodHeader,
        '\t' + '\n\t'.join(validatorLines),
        '\treturn True'
    ]

	entryPoint:str = "if __name__ == '__main__':\n\tprint(f'Got arguments: {parseArgs().__dict__}')"

	# Output everything
	print(shebang, end='\n\n')
	print('# ' + argHeader, end='\n\n')
	print('\n'.join(imports), end='\n\n')
	print(parserMethod, end='\n\n')
	print('\n'.join(validatorMethod), end='\n\n')
	print(entryPoint)
	
	return 0

def standardise(spec:dict, schema:dict) -> dict:
	# Precondition: the spec has been validated against the schema
	if 'program' not in spec:
		spec['program'] = schema['program']['default']
	if 'args' not in spec:
		spec['args'] = []
	else:
		for arg in spec['args']:
			if 'help' not in arg:
				arg['help'] = ''
	return spec

def main(args:[str]) -> int:
	spec:dict
	try:
		spec = json.load(sys.stdin)
	except json.decoder.JSONDecodeError as jsonde:
		printe(str(jsonde) + f' while handling json from stdin')
		return -1

	schema:dict
	with open(defaultSchemaFile, 'r+') as i:
		try:
			schema = json.load(i)
		except json.decoder.JSONDecodeError as jsonde:
			printe(str(jsonde) + f' while handling schema in "{defaultSchemaFile}"')
			return -1

	try:
		jsonschema.validate(instance=spec, schema=schema)
	except jsonschema.exceptions.ValidationError as ve:
		printe(f'Input specification did not match the schema (using schema: "{defaultSchemaFile}"')
		printe(str(ve))
		return -1

	spec = standardise(spec, schema)

	return toPython(spec)

if __name__ == '__main__':
	try:
		sys.exit(main(sys.argv[1:]))
	except KeyboardInterrupt as ke:
		printe(ke)
		sys.exit(1)