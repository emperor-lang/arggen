import datetime
import json
import jsonschema
import sys
import re

schemaFile:str = '../argspec/coder-arguments-schema.json'

arggenVersion:str = 'v1.0.0'

argHeader:str = 'Argument parser generated by arggen %s at %s' % (arggenVersion, datetime.datetime.now())

def printe(arg:object) -> None:
    print(str(arg), file=sys.stderr)

def wrapDefaultValue(value:str, valueType:str) -> str:
    if valueType == 'string':
        return f'"{value}"'
    elif valueType == 'char':
        return f"'{value}'"
    else:
        return value

# # Setup draft 7 validator to replace defaults
# # Helpfully transposed from 
# # https://stackoverflow.com/questions/41290777/trying-to-make-json-schema-validator-in-python-to-set-default-values
# def extendValidatorToAddDefaults(validator:object) -> object:
#     propertyValidator = validator.VALIDATORS["properties"]

#     def setDefaultValues(val, properties, instance:dict, schema:dict):
#         for property_, subschema in properties.items():
#             if "default" in subschema and not isinstance(instance, list):
#                 instance.setdefault(property_, subschema["default"])

#         for error in setDefaultValues(val, properties, instance, schema):
#             yield error

#     return jsonschema.validators.extend(validator, {"properties": setDefaultValues})

# jsonschema.FillDefaultValidatingDraft7Validator = extendValidatorToAddDefaults(jsonschema.Draft7Validator)

def toHaskell(spec:dict) -> int:
    typeMap:dict = {
        'string' : 'String',
        'char' : 'Char',
        'int' : 'Integer',
        'flag' : 'Bool',
        'help': 'Bool'
    }

    imports:str = 'module Args where\nimport Control.Monad\nimport System.Environment\nimport Data.Char\nimport Data.List\n\nnewtype Error = Error String'

    argSpecSetup:str = (
    'parseArgv :: IO Args\n'
    'parseArgv = do\n'
    '    args <- getArgs\n'
    '    let arguments = parseArgs\' args\n'
    '    when (__help__ arguments) $ putStrLn "Some help here"\n'
    # '    else\n'
    # '        putStrLn "Nothing"\n'
    '    return $ arguments\n'
    '\n'
    'parseArgs :: [String] -> Args\n'
    'parseArgs args = parseArgs\' args\n'
    '\n'
    'makeChar :: String -> Char\n'
    'makeChar [] = error "Characters should be non-empty"\n'
    'makeChar xs\n'
    '    | null xs = error "Please give a character"\n'
    '    | length xs >= 2 = error "Too many characters given, expected one here"\n'
    '    | otherwise = head xs\n'
    )

    matchLines:[str] = ['parseArgs\' :: String -> [String] -> Args']
    validatorLines:[str] = ['validArg :: (String,String) -> Bool']
    argTypes:str = '__help__ :: Bool'
    defaultArgs:[str] = ['__help__ = False']
    helpFlag:str = ''

    for arg in spec['args']:
        dest:str = arg['dest'] if arg['type'] != 'help' else '__help__'
        argtype:str = typeMap[arg['type']]
        default = arg['default']

        getArgString:str
        argGrabber:str
        if arg['type'] == 'int':
            argGrabber = ':x'
            getArgString = f'read x :: Integer'
        elif arg['type'] == 'char':
            argGrabber = ':c'
            getArgString = f'makeChar c'
        elif arg['type'] == 'flag':
            argGrabber = ''
            getArgString = 'True'
        elif arg['type'] == 'help':
            argGrabber = ''
            getArgString = 'True'
            if helpFlag == '':
                helpFlag = arg['short'] if 'short' in arg else arg['long']
        elif arg['type'] == 'string':
            argGrabber = ':s'
            getArgString = 's'
        else:
            printe('Unrecognised argument type: %s' % arg['type'])
            return -1

        shortName:str = ''
        if 'short' in arg:
            shortName = arg['short']
            matchLines.append(f'parseArgs\' p ("{shortName}"{argGrabber}:args) = (parseArgs\' p args) {{ {dest} = {getArgString} }}')

        longName:str = ''
        if 'long' in arg:
            longName = arg['long']
            matchLines.append(f'parseArgs\' p ("{longName}"{argGrabber}:args) = (parseArgs\' p args) {{ {dest} = {getArgString} }}')
        
        validatorLines.append(f'validArg ("{dest}",s) = isNum s')

        if arg['type'] != 'help':
            formattedDefault = wrapDefaultValue(default, arg['type'])
            defaultArgs.append(f'{dest} = {formattedDefault}')
            argTypes += (', ' if argTypes != '' else '') + f'{dest} :: {argtype}'

    matchLines.append('parseArgs\' _ [] = defaultArgs')
    matchLines.append(f'parseArgs\' p (arg:args) = error $ "Unrecognised option: " ++ arg ++ "\\ntry `" ++ p ++ " {helpFlag}\' for more information"')
    validatorLines.append('validArg _ = True')
    argTypes = f'data Args = Args {{ {argTypes} }}\n    deriving Show'
    defaultArgsString:str = ', '.join(defaultArgs)
    defaultArgsString = f'defaultArgs :: Args\ndefaultArgs = Args {{ {defaultArgsString} }}'

    print('-- %s' % argHeader, end='\n\n')
    print(imports)
    print(argTypes, end='\n\n')
    print(defaultArgsString)
    print(argSpecSetup)
    print('\n'.join(matchLines))
    # print('\n'.join(validatorLines))

def standardise(spec:dict, schema:dict) -> dict:
    # Precondition: the spec has been validated against the schema
    if 'program' not in spec:
        spec['program'] = schema['program']['default']
    if 'args' not in spec:
        spec['args'] = []
    else:
        for arg in spec['args']:
            if 'help' not in arg:
                arg['help'] = ''

    return spec

def main(args:[str]) -> int:
    spec:dict
    try:
        spec = json.load(sys.stdin)
    except json.decoder.JSONDecodeError as jsonde:
        printe(str(jsonde) + f' while handling json from stdin')
        return -1

    schema:dict
    with open(schemaFile, 'r+') as i:
        try:
            schema = json.load(i)
        except json.decoder.JSONDecodeError as jsonde:
            printe(str(jsonde) + f' while handling schema in "{schemaFile}"')
            return -1

    try:
        jsonschema.validate(instance=spec, schema=schema)
    except jsonschema.exceptions.ValidationError as ve:
        printe(f'Input specification did not match the schema (using schema: "{schemaFile}"')
        printe(str(ve))
        return -1

    spec = standardise(spec, schema)
    return toHaskell(spec)

if __name__ == '__main__':
    try:
        sys.exit(main(sys.argv[1:]))
    except KeyboardInterrupt as ke:
        printe(ke)
        sys.exit(1)